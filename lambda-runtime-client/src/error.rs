//! This module defines the `RuntimeApiError` trait that developers should implement
//! to send their custom errors to the AWS Lambda Runtime Client SDK. The module also
//! defines the `ApiError` type returned by the `RuntimeClient` implementations.
use backtrace;
use http::{header::ToStrError, uri::InvalidUri};
use hyper;
use log::*;
use serde_derive::*;
use serde_json;
use std::{
    env,
    error::Error,
    fmt::{self, Display},
    io,
    num::ParseIntError,
    option::Option,
};

/// Error type description for the `ErrorResponse` event. This type should be returned
/// for errors that were handled by the function code or framework.
#[allow(dead_code)]
pub(crate) const ERROR_TYPE_HANDLED: &str = "Handled";
/// Error type description for the `ErrorResponse` event. This type is used for unhandled,
/// unexpcted errors.
pub(crate) const ERROR_TYPE_UNHANDLED: &str = "Unhandled";
/// Error type for the error responses to the Runtime APIs. In the future, this library
/// should use a customer-generated error code
pub const RUNTIME_ERROR_TYPE: &str = "RustRuntimeError";

/// This object is used to generate requests to the Lambda Runtime APIs.
/// It is used for both the error response APIs and fail init calls.
/// custom error types should implement the `RuntimeError` trait and return
/// this object to be compatible with the APIs.
#[derive(Serialize)]
pub struct ErrorResponse {
    /// The error message generated by the application.
    #[serde(rename = "errorMessage")]
    pub error_message: String,
    /// The error type for Lambda. This can be `Handled` or `Unhandled`.
    /// Developers can use the `ERROR_TYPE_HANDLED` and `ERROR_TYPE_UNHANDLED`
    /// constants to populate this field.
    #[serde(rename = "errorType")]
    pub error_type: String,
    /// The stack trace for the exception as vector of strings. In the framework,
    /// this value is automatically populated using the `backtrace` crate.
    #[serde(rename = "stackTrace")]
    pub stack_trace: Option<Vec<String>>,
}

impl ErrorResponse {
    /// Creates a new instance of the `ErrorResponse` object with the given parameters. If the
    /// `RUST_BACKTRACE` env variable is `1` the `ErrorResponse` is populated with the backtrace
    /// collected through the [`backtrace` craete](https://crates.io/crates/backtrace).
    ///
    /// # Arguments
    ///
    /// * `message` The error message to be returned to the APIs. Normally the error description()
    /// * `err_type` The error type. Use the `ERROR_TYPE_HANDLED` and `ERROR_TYPE_UNHANDLED`.
    /// * `code` A custom error code
    ///
    /// # Return
    /// A new instance of the `ErrorResponse` object.
    fn new(message: String, err_type: String) -> ErrorResponse {
        let mut err = ErrorResponse {
            error_message: message,
            error_type: err_type,
            stack_trace: Option::default(),
        };
        let is_backtrace = env::var("RUST_BACKTRACE");
        if is_backtrace.is_ok() && is_backtrace.unwrap() == "1" {
            trace!("Begin backtrace collection");
            let trace = Option::from(backtrace::Backtrace::new());
            let trace_string = format!("{:?}", trace)
                .lines()
                .map(|s| s.to_string())
                .collect::<Vec<String>>();
            trace!("Completed backtrace collection");
            err.stack_trace = Option::from(trace_string);
        }
        err
    }

    /// Creates a new `RuntimeError` object with the handled error type.
    ///
    /// # Arguments
    ///
    /// * `message` The error message for the Lambda Runtime APIs.
    ///
    /// # Return
    /// A populated `RuntimeError` object that can be used with the Lambda Runtime API.
    pub fn handled(message: String) -> ErrorResponse {
        ErrorResponse::new(message, RUNTIME_ERROR_TYPE.to_owned())
    }

    /// Creates a new `RuntimeError` object with the unhandled error type.
    ///
    /// # Arguments
    ///
    /// * `message` The error message for the Lambda Runtime APIs.
    ///
    /// # Return
    /// A populated `RuntimeError` object that can be used with the Lambda Runtime API.
    pub fn unhandled(message: String) -> ErrorResponse {
        ErrorResponse::new(message, RUNTIME_ERROR_TYPE.to_owned())
    }
}

impl<T: Display + Send + Sync> From<Box<T>> for ErrorResponse {
    fn from(e: Box<T>) -> Self {
        Self::handled(format!("{}", e))
    }
}

/// Represents an error generated by the Lambda Runtime API client.
#[derive(Debug, Clone)]
pub struct ApiError {
    msg: String,
    /// Whether the current error is recoverable. If the error is not
    /// recoverable a runtime should panic to force the Lambda service
    /// to restart the execution environment.
    pub recoverable: bool,
}

impl ApiError {
    pub(crate) fn new(description: &str) -> ApiError {
        ApiError {
            msg: String::from(description),
            recoverable: true,
        }
    }

    pub(crate) fn unrecoverable(&mut self) -> &ApiError {
        self.recoverable = false;

        self
    }
}

impl fmt::Display for ApiError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.msg)
    }
}

// This is important for other errors to wrap this one.
impl Error for ApiError {
    fn description(&self) -> &str {
        &self.msg
    }

    fn cause(&self) -> Option<&dyn Error> {
        // Generic error, underlying cause isn't tracked.
        None
    }
}
unsafe impl Send for ApiError {}
unsafe impl Sync for ApiError {}

impl From<serde_json::Error> for ApiError {
    fn from(e: serde_json::Error) -> Self {
        ApiError::new(e.description())
    }
}

impl From<InvalidUri> for ApiError {
    fn from(e: InvalidUri) -> Self {
        ApiError::new(e.description())
    }
}

impl From<hyper::Error> for ApiError {
    fn from(e: hyper::Error) -> Self {
        ApiError::new(e.description())
    }
}

impl From<ToStrError> for ApiError {
    fn from(e: ToStrError) -> Self {
        ApiError::new(e.description())
    }
}

impl From<ParseIntError> for ApiError {
    fn from(e: ParseIntError) -> Self {
        ApiError::new(e.description())
    }
}

impl From<io::Error> for ApiError {
    fn from(e: io::Error) -> Self {
        ApiError::new(e.description())
    }
}
